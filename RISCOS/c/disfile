/*******************************************************************
 * File:        disfile
 * Purpose:     Disassemble a single file
 * Author:      Gerph
 * Date:        16 Jun 2024
 ******************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "swis.h"

#include "rodis.h"
#include "cli-parser.h"


void error(char *message)
{
    printf("ERROR: %s\n", message);
    exit(1);
}


int get_filetype(const char *filename)
{
    int type;
    _kernel_oserror *err;
    err = _swix(OS_File, _INR(0, 1)|_OUT(6), 20, filename, &type);
    if (err)
        return -1;
    return type;
}


void disassemble_file(char *filename, int thumb, uint32_t start, uint32_t end)
{
    FILE *f;
    uint32_t word;
    uint32_t address;

    f = fopen(filename, "rb");
    if (f == NULL)
        error("File not found");

    address = 0;
    if (strstr(filename, ",ff8") != NULL ||
        get_filetype(filename) == 0xFF8)
        address = 0x8000;

    if (start < address)
    {
        start = address;
    }
    if (end < address)
    {
        goto exit;
    }

    if (start != address)
    {
        fseek(f, start - address, SEEK_SET);
        address = start;
    }

    while (!feof(f) && address < end)
    {
        int instsize = thumb ? 2 : 4;
        if (fread(&word, instsize, 1, f) != 1)
            break;

        printf("%08lx : ", address);
        if (thumb)
            printf("%04lx : ", word);
        else
            printf("%08lx : ", word);

        /* Write out the textual form of the word */
        {
            int i;
            for (i=0; i<instsize; i++)
            {
                char value = (char)(word >> (8*i)) & 0xFF;
                if (value < 32)
                    value = '.';
                else if (value == 127)
                    value = '.';
                printf("%c", value);
            }
        }
        printf(" : ");

        {
            const char *dis = disassemble_word(word, address, thumb);
            printf("%s\n", dis);
        }

        address += instsize;
    }

exit:
    fclose(f);
}


int main(int argc, char *argv[])
{
    char *filename;
    int thumb = 0;
    uint32_t start = 0;
    uint32_t end = 0xFFFFFFFF;

    if (argc < 2 | argc > 5)
    {
        printf("Syntax: %s <filename> [<address> [[+|-]<address> [[+|-]<address>]", argv[0]);
        exit(1);
    }

    if (strcmp(argv[1], "-thumb") == 0)
    {
        thumb = 1;
        filename = argv[2];
        argv+=3;
        argc-=3;
    }
    else
    {
        filename = argv[1];
        argv+=2;
        argc-=2;
    }

    /* Construct a big string from the following arguments */
    {
        static char cmdline[256] = "";
        while (argc)
        {
            char *str = *argv;

            strcat(cmdline, str);
            strcat(cmdline, " ");

            argc--;
            argv++;
        }

        {
            /* Parse the parameters into addresses */
            parsed_arch_t parsed_arch;
            memory_params_t memory_params;
            int inst_width;
            int success;
            const char *arg_string = cmdline;

            arg_string = parse_architecture(arg_string, &parsed_arch);

            inst_width = parsed_arch.inst_width_max;
            printf("Arg_string = %s\n", arg_string);
            printf("inst_width = %i\n", inst_width);
            printf("arch = %i\n", parsed_arch.arch);

            success = parse_memory_params(arg_string, &memory_params, 0x8000000);
            if (!success)
            {
                printf("Failed\n");
                exit(1);
            }

            start = memory_params.base_addr;
            end = memory_params.end_addr;
        }
    }

    disassemble_file(filename, thumb, start, end);
}
